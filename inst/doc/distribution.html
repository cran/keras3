<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Distributed training with Keras 3</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Distributed training with Keras 3</h1>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>The Keras distribution API is a new interface designed to facilitate
distributed deep learning across a variety of backends like JAX,
TensorFlow and PyTorch. This powerful API introduces a suite of tools
enabling data and model parallelism, allowing for efficient scaling of
deep learning models on multiple accelerators and hosts. Whether
leveraging the power of GPUs or TPUs, the API provides a streamlined
approach to initializing distributed environments, defining device
meshes, and orchestrating the layout of tensors across computational
resources. Through classes like <code>DataParallel</code> and
<code>ModelParallel</code>, it abstracts the complexity involved in
parallel computation, making it easier for developers to accelerate
their machine learning workflows.</p>
</div>
<div id="how-it-works" class="section level2">
<h2>How it works</h2>
<p>The Keras distribution API provides a global programming model that
allows developers to compose applications that operate on tensors in a
global context (as if working with a single device) while automatically
managing distribution across many devices. The API leverages the
underlying framework (e.g. JAX) to distribute the program and tensors
according to the sharding directives through a procedure called single
program, multiple data (SPMD) expansion.</p>
<p>By decoupling the application from sharding directives, the API
enables running the same application on a single device, multiple
devices, or even multiple clients, while preserving its global
semantics.</p>
</div>
<div id="setup" class="section level2">
<h2>Setup</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># This guide assumes there are 8 GPUs available for testing. If you don&#39;t have</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co"># 8 gpus available locally, you can set the following envvar to</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co"># make xla initialize the CPU as 8 devices, to enable local testing</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">Sys.setenv</span>(<span class="st">&quot;CUDA_VISIBLE_DEVICES&quot;</span> <span class="ot">=</span> <span class="st">&quot;&quot;</span>)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="fu">Sys.setenv</span>(<span class="st">&quot;XLA_FLAGS&quot;</span> <span class="ot">=</span> <span class="st">&quot;--xla_force_host_platform_device_count=8&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(keras3)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co"># The distribution API is only implemented for the JAX backend for now.</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="fu">use_backend</span>(<span class="st">&quot;jax&quot;</span>)</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>jax <span class="ot">&lt;-</span> reticulate<span class="sc">::</span><span class="fu">import</span>(<span class="st">&quot;jax&quot;</span>)</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="fu">library</span>(tfdatasets, <span class="at">exclude =</span> <span class="st">&quot;shape&quot;</span>) <span class="co"># For dataset input.</span></span></code></pre></div>
</div>
<div id="devicemesh-and-tensorlayout" class="section level2">
<h2><code>DeviceMesh</code> and <code>TensorLayout</code></h2>
<p>The <code>keras$distribution$DeviceMesh</code> class in Keras
distribution API represents a cluster of computational devices
configured for distributed computation. It aligns with similar concepts
in <a href="https://jax.readthedocs.io/en/latest/jax.sharding.html#jax.sharding.Mesh"><code>jax.sharding.Mesh</code></a>
and <a href="https://www.tensorflow.org/api_docs/python/tf/experimental/dtensor/Mesh"><code>tf.dtensor.Mesh</code></a>,
where it’s used to map the physical devices to a logical mesh
structure.</p>
<p>The <code>TensorLayout</code> class then specifies how tensors are
distributed across the <code>DeviceMesh</code>, detailing the sharding
of tensors along specified axes that correspond to the names of the axes
in the <code>DeviceMesh</code>.</p>
<p>You can find more detailed concept explainers in the <a href="https://www.tensorflow.org/guide/dtensor_overview#dtensors_model_of_distributed_tensors">TensorFlow
DTensor guide</a>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Retrieve the local available gpu devices.</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>devices <span class="ot">&lt;-</span> jax<span class="sc">$</span><span class="fu">devices</span>() <span class="co"># &quot;gpu&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="fu">str</span>(devices)</span></code></pre></div>
<pre><code>## List of 8
##  $ :TFRT_CPU_0
##  $ :TFRT_CPU_1
##  $ :TFRT_CPU_2
##  $ :TFRT_CPU_3
##  $ :TFRT_CPU_4
##  $ :TFRT_CPU_5
##  $ :TFRT_CPU_6
##  $ :TFRT_CPU_7</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Define a 2x4 device mesh with data and model parallel axes</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>mesh <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">DeviceMesh</span>(</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="at">shape =</span> <span class="fu">shape</span>(<span class="dv">2</span>, <span class="dv">4</span>),</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  <span class="at">axis_names =</span> <span class="fu">list</span>(<span class="st">&quot;data&quot;</span>, <span class="st">&quot;model&quot;</span>),</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>  <span class="at">devices =</span> devices</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>)</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co"># A 2D layout, which describes how a tensor is distributed across the</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co"># mesh. The layout can be visualized as a 2D grid with &quot;model&quot; as rows and</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co"># &quot;data&quot; as columns, and it is a [4, 2] grid when it mapped to the physical</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="co"># devices on the mesh.</span></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>layout_2d <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">TensorLayout</span>(</span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>  <span class="at">axes =</span> <span class="fu">c</span>(<span class="st">&quot;model&quot;</span>, <span class="st">&quot;data&quot;</span>),</span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a>  <span class="at">device_mesh =</span> mesh</span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a>)</span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a><span class="co"># A 4D layout which could be used for data parallelism of an image input.</span></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a>replicated_layout_4d <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">TensorLayout</span>(</span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a>  <span class="at">axes =</span> <span class="fu">list</span>(<span class="st">&quot;data&quot;</span>, <span class="cn">NULL</span>, <span class="cn">NULL</span>, <span class="cn">NULL</span>),</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>  <span class="at">device_mesh =</span> mesh</span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="distribution" class="section level2">
<h2>Distribution</h2>
<p>The <code>Distribution</code> class in Keras serves as a foundational
abstract class designed for developing custom distribution strategies.
It encapsulates the core logic needed to distribute a model’s variables,
input data, and intermediate computations across a device mesh. As an
end user, you won’t have to interact directly with this class, but its
subclasses like <code>DataParallel</code> or
<code>ModelParallel</code>.</p>
</div>
<div id="dataparallel" class="section level2">
<h2>DataParallel</h2>
<p>The <code>DataParallel</code> class in the Keras distribution API is
designed for the data parallelism strategy in distributed training,
where the model weights are replicated across all devices in the
<code>DeviceMesh</code>, and each device processes a portion of the
input data.</p>
<p>Here is a sample usage of this class.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Create DataParallel with list of devices.</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co"># As a shortcut, the devices can be skipped,</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co"># and Keras will detect all local available devices.</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co"># E.g. data_parallel &lt;- DataParallel()</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>data_parallel <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">DataParallel</span>(<span class="at">devices =</span> devices)</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co"># Or you can choose to create DataParallel with a 1D `DeviceMesh`.</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>mesh_1d <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">DeviceMesh</span>(</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>  <span class="at">shape =</span> <span class="fu">shape</span>(<span class="dv">8</span>),</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>  <span class="at">axis_names =</span> <span class="fu">list</span>(<span class="st">&quot;data&quot;</span>),</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>  <span class="at">devices =</span> devices</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>)</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>data_parallel <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">DataParallel</span>(<span class="at">device_mesh =</span> mesh_1d)</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>inputs <span class="ot">&lt;-</span> <span class="fu">random_normal</span>(<span class="fu">c</span>(<span class="dv">128</span>, <span class="dv">28</span>, <span class="dv">28</span>, <span class="dv">1</span>))</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>labels <span class="ot">&lt;-</span> <span class="fu">random_normal</span>(<span class="fu">c</span>(<span class="dv">128</span>, <span class="dv">10</span>))</span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a>dataset <span class="ot">&lt;-</span> <span class="fu">tensor_slices_dataset</span>(<span class="fu">c</span>(inputs, labels)) <span class="sc">|&gt;</span></span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a>  <span class="fu">dataset_batch</span>(<span class="dv">16</span>)</span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a><span class="co"># Set the global distribution.</span></span>
<span id="cb6-21"><a href="#cb6-21" tabindex="-1"></a>keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">set_distribution</span>(data_parallel)</span>
<span id="cb6-22"><a href="#cb6-22" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" tabindex="-1"></a><span class="co"># Note that all the model weights from here on are replicated to</span></span>
<span id="cb6-24"><a href="#cb6-24" tabindex="-1"></a><span class="co"># all the devices of the `DeviceMesh`. This includes the RNG</span></span>
<span id="cb6-25"><a href="#cb6-25" tabindex="-1"></a><span class="co"># state, optimizer states, metrics, etc. The dataset fed into `model |&gt; fit()` or</span></span>
<span id="cb6-26"><a href="#cb6-26" tabindex="-1"></a><span class="co"># `model |&gt; evaluate()` will be split evenly on the batch dimension, and sent to</span></span>
<span id="cb6-27"><a href="#cb6-27" tabindex="-1"></a><span class="co"># all the devices. You don&#39;t have to do any manual aggregation of losses,</span></span>
<span id="cb6-28"><a href="#cb6-28" tabindex="-1"></a><span class="co"># since all the computation happens in a global context.</span></span>
<span id="cb6-29"><a href="#cb6-29" tabindex="-1"></a>inputs <span class="ot">&lt;-</span> <span class="fu">keras_input</span>(<span class="at">shape =</span> <span class="fu">c</span>(<span class="dv">28</span>, <span class="dv">28</span>, <span class="dv">1</span>))</span>
<span id="cb6-30"><a href="#cb6-30" tabindex="-1"></a>outputs <span class="ot">&lt;-</span> inputs <span class="sc">|&gt;</span></span>
<span id="cb6-31"><a href="#cb6-31" tabindex="-1"></a>  <span class="fu">layer_flatten</span>() <span class="sc">|&gt;</span></span>
<span id="cb6-32"><a href="#cb6-32" tabindex="-1"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">200</span>, <span class="at">use_bias =</span> <span class="cn">FALSE</span>, <span class="at">activation =</span> <span class="st">&quot;relu&quot;</span>) <span class="sc">|&gt;</span></span>
<span id="cb6-33"><a href="#cb6-33" tabindex="-1"></a>  <span class="fu">layer_dropout</span>(<span class="fl">0.4</span>) <span class="sc">|&gt;</span></span>
<span id="cb6-34"><a href="#cb6-34" tabindex="-1"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">10</span>, <span class="at">activation =</span> <span class="st">&quot;softmax&quot;</span>)</span>
<span id="cb6-35"><a href="#cb6-35" tabindex="-1"></a></span>
<span id="cb6-36"><a href="#cb6-36" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">keras_model</span>(<span class="at">inputs =</span> inputs, <span class="at">outputs =</span> outputs)</span>
<span id="cb6-37"><a href="#cb6-37" tabindex="-1"></a></span>
<span id="cb6-38"><a href="#cb6-38" tabindex="-1"></a>model <span class="sc">|&gt;</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">&quot;mse&quot;</span>)</span>
<span id="cb6-39"><a href="#cb6-39" tabindex="-1"></a>model <span class="sc">|&gt;</span> <span class="fu">fit</span>(dataset, <span class="at">epochs =</span> <span class="dv">3</span>)</span></code></pre></div>
<pre><code>## Epoch 1/3
## 8/8 - 0s - 37ms/step - loss: 1.0629
## Epoch 2/3
## 8/8 - 0s - 5ms/step - loss: 0.9712
## Epoch 3/3
## 8/8 - 0s - 5ms/step - loss: 0.9322</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>model <span class="sc">|&gt;</span> <span class="fu">evaluate</span>(dataset)</span></code></pre></div>
<pre><code>## 8/8 - 0s - 7ms/step - loss: 0.8859</code></pre>
<pre><code>## $loss
## [1] 0.8858577</code></pre>
</div>
<div id="modelparallel-and-layoutmap" class="section level2">
<h2><code>ModelParallel</code> and <code>LayoutMap</code></h2>
<p><code>ModelParallel</code> will be mostly useful when model weights
are too large to fit on a single accelerator. This setting allows you to
spit your model weights or activation tensors across all the devices on
the <code>DeviceMesh</code>, and enable the horizontal scaling for the
large models.</p>
<p>Unlike the <code>DataParallel</code> model where all weights are
fully replicated, the weights layout under <code>ModelParallel</code>
usually need some customization for best performances. We introduce
<code>LayoutMap</code> to let you specify the <code>TensorLayout</code>
for any weights and intermediate tensors from global perspective.</p>
<p><code>LayoutMap</code> is a dict-like object that maps a string to
<code>TensorLayout</code> instances. It behaves differently from a
normal dict in that the string key is treated as a regex when retrieving
the value. The class allows you to define the naming schema of
<code>TensorLayout</code> and then retrieve the corresponding
<code>TensorLayout</code> instance. Typically, the key used to query is
the <code>variable$path</code> attribute, which is the identifier of the
variable. As a shortcut, a list of axis names is also allowed when
inserting a value, and it will be converted to
<code>TensorLayout</code>.</p>
<p>The <code>LayoutMap</code> can also optionally contain a
<code>DeviceMesh</code> to populate the
<code>TensorLayout$device_mesh</code> if it is not set. When retrieving
a layout with a key, and if there isn’t an exact match, all existing
keys in the layout map will be treated as regex and matched against the
input key again. If there are multiple matches, a
<code>ValueError</code> is raised. If no matches are found,
<code>NULL</code> is returned.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>mesh_2d <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">DeviceMesh</span>(</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  <span class="at">shape =</span> <span class="fu">shape</span>(<span class="dv">2</span>, <span class="dv">4</span>),</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="at">axis_names =</span> <span class="fu">c</span>(<span class="st">&quot;data&quot;</span>, <span class="st">&quot;model&quot;</span>),</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  <span class="at">devices =</span> devices</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>)</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>layout_map  <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">LayoutMap</span>(mesh_2d)</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a><span class="co"># The rule below means that for any weights that match with d1/kernel, it</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a><span class="co"># will be sharded with model dimensions (4 devices), same for the d1/bias.</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a><span class="co"># All other weights will be fully replicated.</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>layout_map[<span class="st">&quot;d1/kernel&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">tuple</span>(<span class="cn">NULL</span>, <span class="st">&quot;model&quot;</span>)</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>layout_map[<span class="st">&quot;d1/bias&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">tuple</span>(<span class="st">&quot;model&quot;</span>)</span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a><span class="co"># You can also set the layout for the layer output like</span></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>layout_map[<span class="st">&quot;d2/output&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">tuple</span>(<span class="st">&quot;data&quot;</span>, <span class="cn">NULL</span>)</span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>model_parallel <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">ModelParallel</span>(</span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a>  mesh_2d, layout_map, <span class="at">batch_dim_name =</span> <span class="st">&quot;data&quot;</span></span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a>)</span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">set_distribution</span>(model_parallel)</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a>inputs <span class="ot">&lt;-</span> <span class="fu">layer_input</span>(<span class="at">shape =</span> <span class="fu">c</span>(<span class="dv">28</span>, <span class="dv">28</span>, <span class="dv">1</span>))</span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a>outputs <span class="ot">&lt;-</span> inputs <span class="sc">|&gt;</span></span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>  <span class="fu">layer_flatten</span>() <span class="sc">|&gt;</span></span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">200</span>, <span class="at">use_bias =</span> <span class="cn">FALSE</span>,</span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a>              <span class="at">activation =</span> <span class="st">&quot;relu&quot;</span>, <span class="at">name =</span> <span class="st">&quot;d1&quot;</span>) <span class="sc">|&gt;</span></span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a>  <span class="fu">layer_dropout</span>(<span class="fl">0.4</span>) <span class="sc">|&gt;</span></span>
<span id="cb11-29"><a href="#cb11-29" tabindex="-1"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">10</span>,</span>
<span id="cb11-30"><a href="#cb11-30" tabindex="-1"></a>              <span class="at">activation =</span> <span class="st">&quot;softmax&quot;</span>,</span>
<span id="cb11-31"><a href="#cb11-31" tabindex="-1"></a>              <span class="at">name =</span> <span class="st">&quot;d2&quot;</span>)</span>
<span id="cb11-32"><a href="#cb11-32" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">keras_model</span>(<span class="at">inputs =</span> inputs, <span class="at">outputs =</span> outputs)</span>
<span id="cb11-34"><a href="#cb11-34" tabindex="-1"></a></span>
<span id="cb11-35"><a href="#cb11-35" tabindex="-1"></a><span class="co"># The data will be sharded across the &quot;data&quot; dimension of the method, which</span></span>
<span id="cb11-36"><a href="#cb11-36" tabindex="-1"></a><span class="co"># has 2 devices.</span></span>
<span id="cb11-37"><a href="#cb11-37" tabindex="-1"></a>model <span class="sc">|&gt;</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">&quot;mse&quot;</span>)</span>
<span id="cb11-38"><a href="#cb11-38" tabindex="-1"></a>model <span class="sc">|&gt;</span> <span class="fu">fit</span>(dataset, <span class="at">epochs =</span> <span class="dv">3</span>)</span></code></pre></div>
<pre><code>## Epoch 1/3
## 8/8 - 0s - 29ms/step - loss: 1.0714
## Epoch 2/3
## 8/8 - 0s - 3ms/step - loss: 0.9744
## Epoch 3/3
## 8/8 - 0s - 4ms/step - loss: 0.9280</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>model <span class="sc">|&gt;</span> <span class="fu">evaluate</span>(dataset)</span></code></pre></div>
<pre><code>## 8/8 - 0s - 7ms/step - loss: 0.8802</code></pre>
<pre><code>## $loss
## [1] 0.8802156</code></pre>
<p>It is also easy to change the mesh structure to tune the computation
between more data parallel or model parallel. You can do this by
adjusting the shape of the mesh. And no changes are needed for any other
code.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>full_data_parallel_mesh <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">DeviceMesh</span>(</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>  <span class="at">shape =</span> <span class="fu">shape</span>(<span class="dv">8</span>, <span class="dv">1</span>),</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>  <span class="at">axis_names =</span> <span class="fu">list</span>(<span class="st">&quot;data&quot;</span>, <span class="st">&quot;model&quot;</span>),</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>  <span class="at">devices =</span> devices</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>)</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>more_data_parallel_mesh <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">DeviceMesh</span>(</span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>  <span class="at">shape =</span> <span class="fu">shape</span>(<span class="dv">4</span>, <span class="dv">2</span>),</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>  <span class="at">axis_names =</span> <span class="fu">list</span>(<span class="st">&quot;data&quot;</span>, <span class="st">&quot;model&quot;</span>),</span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>  <span class="at">devices =</span> devices</span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a>)</span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a>more_model_parallel_mesh <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">DeviceMesh</span>(</span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a>  <span class="at">shape =</span> <span class="fu">shape</span>(<span class="dv">2</span>, <span class="dv">4</span>),</span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a>  <span class="at">axis_names =</span> <span class="fu">list</span>(<span class="st">&quot;data&quot;</span>, <span class="st">&quot;model&quot;</span>),</span>
<span id="cb16-14"><a href="#cb16-14" tabindex="-1"></a>  <span class="at">devices =</span> devices</span>
<span id="cb16-15"><a href="#cb16-15" tabindex="-1"></a>)</span>
<span id="cb16-16"><a href="#cb16-16" tabindex="-1"></a>full_model_parallel_mesh <span class="ot">&lt;-</span> keras<span class="sc">$</span>distribution<span class="sc">$</span><span class="fu">DeviceMesh</span>(</span>
<span id="cb16-17"><a href="#cb16-17" tabindex="-1"></a>  <span class="at">shape =</span> <span class="fu">shape</span>(<span class="dv">1</span>, <span class="dv">8</span>),</span>
<span id="cb16-18"><a href="#cb16-18" tabindex="-1"></a>  <span class="at">axis_names =</span> <span class="fu">list</span>(<span class="st">&quot;data&quot;</span>, <span class="st">&quot;model&quot;</span>),</span>
<span id="cb16-19"><a href="#cb16-19" tabindex="-1"></a>  <span class="at">devices =</span> devices</span>
<span id="cb16-20"><a href="#cb16-20" tabindex="-1"></a>)</span></code></pre></div>
<div id="further-reading" class="section level3">
<h3>Further reading</h3>
<ol style="list-style-type: decimal">
<li><a href="https://jax.readthedocs.io/en/latest/notebooks/Distributed_arrays_and_automatic_parallelization.html">JAX
Distributed arrays and automatic parallelization</a></li>
<li><a href="https://jax.readthedocs.io/en/latest/jax.sharding.html">JAX
sharding module</a></li>
<li><a href="https://www.tensorflow.org/tutorials/distribute/dtensor_ml_tutorial">TensorFlow
Distributed training with DTensors</a></li>
<li><a href="https://www.tensorflow.org/guide/dtensor_overview">TensorFlow
DTensor concepts</a></li>
<li><a href="https://www.tensorflow.org/tutorials/distribute/dtensor_keras_tutorial">Using
DTensors with tf.keras</a></li>
</ol>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
